const bcrypt = require("bcryptjs");
const mongoose = require("mongoose");

/*
This is the mongoose schema used for representing the user records.
*/
const userSchema = mongoose.Schema(
  {
    // allows user to have a name
    name: {
      type: String,
      // ensures the users must have a name
      required: [true, "Users must have a name!"],
    },
    // registered user will have a password
    email: {
      type: String,
      // ensures that all users that are registered on our website (i.e. not guest users) must have an email
      required: [
        function () {
          return this.groupID === 26;
        },
        "Users must have an email!",
      ],
    },
    // unique user id, this is neede for supergroup communication
    userID: {
      type: String,
      // ensures all users have a user id
      unique: [true, "Generated user id must be unique!"],
      /*
      If no user id is specified, then a dynamic default value will be used.
      This default is only set for users registered on our website. 
      It combines our gorup's number and the id generated by mongodb.
      */
      default: function () {
        return "G" + this.groupID + "-" + this.id;
      },
    },
    // the user's group id, used for supergroup communication
    groupID: {
      type: Number,
      // all the values that the field can have
      enum: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
      // Default value is our group. All users registered on our website will have the default value set.
      default: 26,
    },
    // a profile picture (functionality currently not in use)
    photo: {
      type: String,
      default: "default.jpg",
    },
    // the user's role
    role: {
      type: String,
      // can be only one of those mentioned below
      enum: ["solver", "creator", "administrator", "checker"],
      // as default, when a new user is created, it is assigned the "solver" role
      default: "solver",
    },
    //a ll registered users must have a password
    password: {
      type: String,
      // this function ensures that all user whose group is 26, i.e. users registered on our website, must have a password
      required: [
        function () {
          return this.groupID === 26;
        },
        "Please provide a password",
      ],
      // set minimum length for password
      minlength: [8, "Password must have at least 8 characters!"],
      // make sure that whenever fetching the user from the database the password is not served (unless specified)
      select: false,
    },
    // confirmation password
    passwordConfirm: {
      type: String,
      // this is required only for registered users on our webiste, i.e. have group id = 26
      required: [
        function () {
          return this.groupID === 26;
        },
        "Please confirm your password",
      ],
      /*
      When a new user is created or the user tries to change their password,
      this validation function will run automatically. What is does, is to 
      check that both entered passwords are the same.
      */
      validate: {
        // This only works on CREATE and SAVE!!!
        validator: function (el) {
          return el === this.password;
        },
        message: "Passwords are not the same!",
      },
      // as default, this field will not be served when fetching the user from the database
      select: false,
    },
    // the date the user has last changed their password
    passwordChangeDate: { type: Date },
    // reset token and its expiration date (i.e. used for resetting a user's password)
    passwordResetToken: String,
    resetTokenExpiryDate: Date,
    flagged: {
      type: Boolean,
      default: false,
    },
    active: {
      type: Boolean,
      default: true,
    },
    banMessage: {
      subject: String,
      message: String,
    },
    messages: {
      type: [
        {
          subject: String,
          message: String,
          sentAt: Date,
          seen: { type: Boolean, default: false },
        },
      ],
    },
    recentSearchedUsers: {
      type: [
        {
          type: mongoose.Schema.ObjectId,
          ref: "User",
        },
      ],
    },
    recentSearchedPuzzles: {
      type: [
        {
          puzzle: {
            type: mongoose.Schema.ObjectId,
            refPath: "recentSearchedPuzzles.puzzleType",
          },
          puzzleType: {
            type: String,
            required: true,
            enum: ["sudoku", "eights_puzzle", "hashi"],
          },
        },
      ],
    },
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

/* 
This function call is used for partially indexing the users i terms of their password.
The reason for this is to allow storing users that do not have an email (i.e. guest users),
but for those that have to impose that they have a unique email.
*/
userSchema.index(
  { email: 1 },
  {
    unique: true,
    partialFilterExpression: {
      email: {
        $exists: true,
        $gt: "",
      },
    },
  }
);

/* 
this field is created on the fly when the user is fetched from the database.
It reflects if the user just fetched is a guest user or not. 
The reason for making this a virtual field was because it can be derived using the user's other fields 
so there was no point in increasing the schema's complexity.
*/
userSchema.virtual("isGuest").get(function () {
  return this.groupID !== 26;
});

userSchema.virtual("numberOfNewMessages").get(function () {
  return this.messages.filter((el) => !el.seen).length;
});

/*userSchema.virtual("numberOfPuzzlesSolved").get(function () {
  return (
    this.solvedPuzzles.easy.length +
    this.solvedPuzzles.medium.length +
    this.solvedPuzzles.hard.length
  );
});*/

/* 
This functino runs before any call to the fuunctin save or create implicitly.
*/
userSchema.pre("save", async function (next) {
  /* 
  If the user is not a new one or if they did not change their password,
  then just skip this function. 
  */
  if (!this.isModified("password")) return next();

  // Hash the password with cost of 12
  /* 
  If the user has just been created or they just changed their password, 
  then make sure to hash the password they have entered before storing it into the database.
  */
  this.password = await bcrypt.hash(this.password, 12);
  // update the date they last changed their password
  this.passwordChangeDate = new Date(new Date().getTime() - 1000 * 60);

  // Delete password confirmation field since it not needed anymore
  this.passwordConfirm = undefined;
  // move to the next function
  next();
});

userSchema.pre("save", async function (next) {
  while (this.recentSearchedUsers.length > 20) {
    this.recentSearchedUsers.pop();
  }
  next();
});

/* 
Function that can be called on the User Model's objects.
This function verifies if the specified password and the hashed one stored 
in the user's record, the function is called on, correspond.
*/
userSchema.methods.correctPassword = async function (
  candidatePassword,
  userPassword
) {
  return await bcrypt.compare(candidatePassword, userPassword);
};

/* 
Function that can be called on the User Model's objects.
This function verifies if the user the function is called on has changed their password
more recently than the specified date
*/
userSchema.methods.changedPasswordAfter = function (date) {
  const changedAt = parseInt(this.passwordChangeDate.getTime() / 1000);
  return changedAt > date;
};

// create a User model
const User = mongoose.model("User", userSchema);

// export the User model.
module.exports = User;
